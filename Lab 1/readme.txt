1. It appears that the incorrect computations are occurring because the calculations from the child process are not being accounted for. This is because the child process is exiting with a status of 0. When the child process is executed, it only modifies the ‘Total’ variable stored in the child process memory space, not the ‘Total’ variable in the parent’s memory space. So the parent process only keeps track of the first half of the summation or A(x) and the child process only keeps track of the second half of the summation or B(x) and since the ‘Total’ Variable is being stored in separate memory spaces, they are not combined automatically when one exits and the other executes. 

2. We thought about bringing the total value into the exit status of the child process. That way, when it is brought back into the child tuple, the parent process can see the calculation total of the child process. Since the exit status returns in a 16-bit integer that includes higher and lower bytes, it returns the child process's total multiplied by * 2^8. So what I did was I divided by 256 before adding it to the total.

3. The value of n at which the sum returns incorrect is 26. This is because the resulting integer value of ‘Total’ from the child process running B(x), ends up at a value of 260. When bringing a value into the exit status of the child process, that value is multiplied by 2^8, *reason stated previously in part 2. But since 260 * 2^8 = 66,560, the value brought back exceeds the 16-bit integer limit of 65,536 which causes an integer overflow of 1024 when bit shifted. So the returned ‘Total’ variable from the child process, B(x), returns a value of 4 instead of 260. 

4. The value of n at which the sum returns incorrect is 46 for the same reasons explained in part 3.